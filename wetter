#!/usr/bin/env ruby
# frozen_string_literal: true

require 'gtk3'
require 'easy_logging'
require 'yaml'
require 'fileutils'
require 'optparse'
# TODO: Write out a comp[ete set of required gems to go on the Github for
#   future end-users and current developers
require_relative 'prefs/prefs'
require_relative 'ui/gui/gui'
require_relative 'storage/storage'

# wetter is an applet that is meant to serve as part of the ADA system
# (Artificially-Intelligent Domestic Assistant) prounounced "Ay-Duh"

EasyLogging.level = Logger::DEBUG

class Wetter
  include EasyLogging
  include Wetter::Prefs
  include Gtk

  glade_path = 'wetter.ui'

  gui = Wetter::Gui
  gui.new(glade_path)
end


#   Builder = Wetter::Gui::Builder
#   MainWin = Wetter::Gui::Windows::Main
#   PrefsWin = Wetter::Gui::Windows::Prefs
#
#   def start_builder(glade_path)
#     logger.debug 'Starting Gui object builder'
#     Builder.start(glade_path)
#     logger.debug 'Started GUI object builder!'
#   end
#
#   def load_settings
#     logger.debug 'Received call to load settings'
#     logger.debug 'Calling on Prefs.loaded'
#     @settings = Prefs.configure
#   end
#
#   # Declare some much needed instance constants
#
#   DefaultFilepath = 'application/run/' # Base run dir where both settings.conf
#   # and stats.db will have their respective
#   # domains.
#   #
#   ConfDir  = "#{DefaultFilepath}conf/" # Dir containing settings.conf
#   StatsDir = "#{DefaultFilepath}stats/" # Dir containing stats.conf
#
#   signal_handler = Wetter::Gui::Signals
#
#   @button_click = signal_handler::OnButtonClick
#
#   def register_main
#     logger.debug 'Register call received | Target: main'
#     @main_window = Builder.main_window
#     logger.debug "Current state of @main_window is #{@main_window}"
#   end
#
#   def register_prefs
#     logger.debug 'Register call received | Target: prefs'
#     @prefs_window = Builder.preferences_window
#     logger.debug "Current state of @prefs_window is #{@prefs_window}"
#   end
#
#   def register_splash
#     logger.debug 'Register call received | Target: splash'
#     @splash_window = Builder.splash_window
#     logger.debug "Current state of @splash_window is: #{@splash_window}"
#   end
#
#   # This method builds all the program windows for later access
#
#   # @return [Object]
#   def build_windows
#     windows = %w[splash main prefs]
#
#     windows.each do |win|
#       case win
#
#       when 'splash'
#         register_splash
#
#       when 'prefs'
#         register_prefs
#
#       when 'main'
#         register_main
#
#       end
#     end
#
#     logger.debug 'Successfully built all windows'
#   end
#
#   def start_signals
#     not_yet_implemented
#   end
#
#   def initialize(glade_path)
#     # Now we can tell the user that we're starting start jobs
#
#     logger.debug 'Running start jobs'
#     begin
#
#       # Starting the builders for the main window and for the
#       # preferences window.
#
#       logger.debug 'Starting GUI builder...'
#       start_builder(glade_path)
#
#       # FIXME: The below is a temporary fix in order to restore
#       #   functionality to app for testing. Should change to
#       #   something with less code
#       logger.debug 'Setting up connect signals with handlers'
#       start_signals
#       logger.debug 'Signals connected!'
#       logger.debug 'Starting builder for preference fields'
#       build_pref_fields
#
#       # Now that the preference fields exist for filling we'll give
#       # them the data that is currently saved.
#       load_settings
#
#       # Build the windows needed for the application
#       logger.debug 'Starting build job for windows'
#       build_windows
#
#     end
#   end
#
#   # This function will build the preference fields that are placed in
#   # the preferences window so they can be filled with data from the conf
#   # files (if they exist)
#   def build_pref_fields
#     logger.debug 'Building Preference Fields'
#     @api_buffer = Builder.get_object 'ApiKeyEntryBuffer'
#     @api_show   = Builder.get_object 'ApiKeyEntry'
#     logger.debug 'Built API preference fields'
#   end
#
#   # This function will be removed/commented out soon, it just exists in
#   # an effort to give all signal-bearing objects a function to call to show
#   # that the signals work for development
#
#   # TODO: Remove this function
#   def not_yet_implemented
#     logger.warn 'This method/feature is not yet impletmented.'
#   end
#
#   # When we receive a signal that the end-user clicked the preferences button
#   # we will create and show the preferences window
#   def on_main_button_prefs_clicked
#     logger.debug 'Received click on Preferences button'
#
#     logger.debug "Current program settings are: #{@settings}"
#     logger.debug 'Calling on preference field builder'
#     build_pref_fields
#     @api_buffer.text = if !@settings[:api_key].nil?
#                          @settings[:api_key]
#                        else
#                          'This has not been set'
#                        end
#
#     logger.debug("API Key is: #{@api_buffer.text}")
#     @api_show.show
#     @prefs_window.show
#     @api_show.text = @api_buffer.text
#   end
#
#   # When we receive a signal that the end-user clicked the refresh button
#   # we deliver a message advising them that this function is not-yet
#   # implemented
#
#   # TODO: Provide function to the refresh button
#
#   def on_main_button_refresh_clicked
#     not_yet_implemented
#   end
#
#   # When we receive a signal that the API Key text entry field was changed
#   # we want to save that information to the @settings hash.
#
#   def on_prefs_entry_api_key_changed
#     @api_buffer.text    = @api_show.text
#     @settings[:api_key] = @api_buffer.text
#   end
#
#   # When we receive a signal that the quit button was pressed we'll want to
#   # destroy the main window and exit the program in a safe and clean way,
#   # hopefully returning no exceptions or error codes
#
#   def on_main_button_quit_clicked
#     @main_window.destroy
#     begin
#       exit
#     rescue SystemExit
#       p 'This is a clean exit' # FIXME: Change or get rid of this message
#       quit
#     end
#   end
#
#   # Handlers for Preferences window signals
#   # FIXME 'ok' button doesn't save, nor does it close the window
#   def on_prefs_win_main_bb_ok_clicked
#     logger.debug('Received click on OK button in preferences window')
#     logger.debug("Settings state: #{@settings}")
#     begin
#       logger.debug('Opening file in write mode')
#       File.open('conf/settings.conf', 'w') do |file|
#         logger.debug('Writing settings file...')
#         file.write @settings.to_yaml
#         logger.debug('File written')
#         @prefs_window.hide
#       end
#     rescue StandardError => e
#       logger.error 'I do not have permission to save settings:'
#       logger.error e.message
#     end
#   end
#
#   # When we receive a signal that the end-user clicked the cancel button from
#   # within the preferences window we will hide the preferences window until
#   # program end, or until called again by the user
#
#   def on_prefs_win_main_bb_cancel_clicked
#     logger.debug('Received click on cancel button, hiding window')
#     @prefs_window.hide
#     logger.debug('Preference window hidden')
#   end
#
#   # Main run function
#
#   def run
#     @@main_window.show
#     sleep(5)
#     @splash_window.destroy
#     Gtk.main
#   end
#
#   # Main quit function, this is called upon by the quit button and the X button
#   # at the top of the window
#
#   def quit
#     Gtk.main_quit
#   end
# end
#
# # Start a new instance of the Wetter application by calling on the run function
# # above.
# #
Wetter.new('wetter.ui')
